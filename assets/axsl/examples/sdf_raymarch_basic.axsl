shader AxDemoRaymarch : sdf_raymarch {
  // uniforms (HXSL: @uniform)
  uniform mat4 uCamera;
  uniform vec3 uLightDir;

  // basic SDF helpers
  fn sdSphere(p: vec3, r: float) -> float {
    return length(p) - r;
  }

  fn sdBox(p: vec3, b: vec3) -> float {
    let d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
  }

  fn map(p: vec3) -> float {
    let sphere = sdSphere(p, 1.0);
    let cut = sdBox(p - vec3(0.0, -0.6, 0.0), vec3(1.2, 0.2, 1.2));
    // carve a trench in the sphere
    return max(sphere, -cut);
  }

  entry fragment mainRaymarch(uv: vec2) -> vec4 {
    // camera ray (placeholder; real app should derive from uCamera)
    let ro = vec3(0.0, 0.0, -5.0);
    let rd = normalize(vec3(uv, 1.4));

    let t = 0.0;
    let hit = false;
    let p = vec3(0.0, 0.0, 0.0);

    for i in 0..96 {
      p = ro + rd * t;
      let d = map(p);
      if (d < 0.001) {
        hit = true;
        break;
      }
      t += d;
      if (t > 40.0) { break; }
    }

    if (!hit) {
      return vec4(0.02, 0.03, 0.05, 1.0); // sky
    }

    let e = 0.001;
    let n = normalize(vec3(
      map(p + vec3(e, 0.0, 0.0)) - map(p - vec3(e, 0.0, 0.0)),
      map(p + vec3(0.0, e, 0.0)) - map(p - vec3(0.0, e, 0.0)),
      map(p + vec3(0.0, 0.0, e)) - map(p - vec3(0.0, 0.0, e))
    ));

    let l = normalize(uLightDir);
    let diff = max(dot(n, l), 0.0);
    let col = vec3(0.8, 0.6, 0.9) * diff + vec3(0.05, 0.06, 0.08);
    return vec4(col, 1.0);
  }
}
